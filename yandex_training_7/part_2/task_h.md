# H. Дерево отрезков с операцией на отрезке<sup>[#](https://contest.yandex.ru/contest/74966/problems/H/)</sup>

| Язык                   | Ограничение времени | Ограничение памяти | Ввод             | Вывод             |
|------------------------|---------------------|--------------------|------------------|-------------------|
| Все языки              | 1.5 секунд          | 512 Мб             | стандартный ввод | стандартный вывод |
| Kotlin 2.1.20 (JRE 21) | 5 секунд            | 512 Мб             | стандартный ввод | стандартный вывод |
| Swift 6.1              | 5 секунд            | 512 Мб             | стандартный ввод | стандартный вывод |
| Python 3.13.2          | 5 секунд            | 512 Мб             | стандартный ввод | стандартный вывод |
| Node.js 22.14.0        | 5 секунд            | 512 Мб             | стандартный ввод | стандартный вывод |


Реализуйте эффективную структуру данных для хранения элементов и увеличения нескольких подряд идущих элементов на одно и то же число.

## Формат ввода

В первой строке вводится одно натуральное число N (1 ⩽ N ⩽ 100000) — количество чисел в массиве.

Во второй строке вводятся N чисел от 0 до 100000 — элементы массива.

В третьей строке вводится одно натуральное число M (1 ⩽ M ⩽ 30000) — количество запросов.

Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (*g* — получить текущее значение элемента по его номеру, *а* — увеличить все элементы на отрезке).

Следом за *g* вводится одно число — номер элемента.

Следом за a вводится три числа — левый и правый концы отрезка и число `add`, на которое нужно увеличить все элементы данного отрезка массива (0 ⩽ `add` ⩽ 100000).

## Формат вывода

Выведите в одну строку через пробел ответы на каждый запрос *g*.

## Пример

| Ввод      | Вывод |
|-----------|-------|
| 5         |     4 |
| 2 4 3 5 2 |     2 |
| 5         |    14 |
| g 2       |     5 |
| g 5       |       |
| a 1 3 10  |       |
| g 2       |       |
| g 4       |       |

